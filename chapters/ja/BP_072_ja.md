## ループ内のSQLクエリを回避する

### 識別子

| GreenIT |  V2  |  V3  |  V4  |
|:-------:|:----:|:----:|:----:|
|   55   |  71 | 72  |      |

### カテゴリ

| ライフサイクル |  サードパーティ  |  担当者  |
|:---------:|:----:|:----:|
| 3. 実現 (製造 / 実装) | データセンター | ソフトウェアアーキテクト/開発者 |

### 効果

| 優先度 |      実装難易度       |  エコロジーへの影響度    |
|:-------------------:|:-------------------------:|:---------------------:|
| 3 | 3 | 3 |

|リソース                                      |
|:----------------------------------------------------------:|
|   プロセッサ  / RAM / ネットワーク  |

### 説明

ループ内でのSQLクエリは、パフォーマンスに大きな問題を引き起こします。特に、SQLサーバーがローカルマシンにない場合、この問題はさらに深刻です。これらのサーバーは、複数の選択、挿入、または修正を一つのクエリまたは一つのトランザクションで処理するために最適化されています。

不適切に使用された場合、これらのクエリはCPUサイクル、RAM、そして帯域幅を無駄に消費します。

### 例

避けるべきは、例えば以下のようなコードです :
```php
foreach ($userList as $user) {
    $query = 'INSERT INTO users (ﬁrst_name,last_name) VALUES("'. $user['ﬁrst_name'] .'", "'. $user['last_ name'] .'")';
    mysql_query($query);
}
```
mais plutôt :
```php
$userData = array();
foreach ($userList as $user) {
    $userData[] = '("'. $user['ﬁrst_name'] .'", "'.
    $user['last_name'] .'")';
}
$query = 'INSERT INTO users (ﬁrst_name,last_name) VALUES'. implode(',', $userData); mysql_query($query);
```

### 検証原理

| 検証項目     | 次の値以下である   |  
|-------------------|:-------------------------:|
|  ループ内でのSQLクエリ  |  0 |
